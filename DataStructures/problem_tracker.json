{
  "arrays": {
    "description": "Array manipulation and searching algorithms",
    "problems": [
      {
        "name": "Two Sum",
        "difficulty": "Easy",
        "description": "Find two numbers that add up to target",
        "file": "arrays_operations.py",
        "method": "two_sum"
      },
      {
        "name": "Binary Search",
        "difficulty": "Easy",
        "description": "Search for target in sorted array",
        "file": "arrays_operations.py",
        "method": "binary_search"
      },
      {
        "name": "Merge Sorted Arrays",
        "difficulty": "Easy",
        "description": "Merge two sorted arrays in-place",
        "file": "arrays_operations.py",
        "method": "merge_sorted_arrays"
      },
      {
        "name": "Remove Duplicates",
        "difficulty": "Easy",
        "description": "Remove duplicates from sorted array in-place",
        "file": "arrays_operations.py",
        "method": "remove_duplicates"
      },
      {
        "name": "Search Insert Position",
        "difficulty": "Easy",
        "description": "Find position where target should be inserted",
        "file": "arrays_operations.py",
        "method": "search_insert_position"
      },
      {
        "name": "First and Last Position",
        "difficulty": "Medium",
        "description": "Find first and last position of target in sorted array",
        "file": "arrays_operations.py",
        "method": "find_first_and_last_position"
      },
      {
        "name": "Linear Search",
        "difficulty": "Easy",
        "description": "Find the index of a target element in an unsorted array",
        "file": "arrays_operations.py",
        "method": "find_element"
      },
      {
        "name": "Find Maximum and Minimum",
        "difficulty": "Easy",
        "description": "Find both the maximum and minimum elements in array in a single pass.",
        "file": "arrays_operations.py",
        "method": "find_min_max"
      },
      {
        "name": "Kadane's Algorithm with Indices",
        "difficulty": "Medium",
        "description": "Find the maximum sum subarray and return both the sum and the start/end indices of the subarray.",
        "file": "arrays_operations.py",
        "method": "kadanes_with_subarray"
      }
    ]
  },
  "sliding_window": {
    "description": "Sliding window pattern problems",
    "problems": [
      {
        "name": "Maximum Subarray Sum",
        "difficulty": "Easy",
        "description": "Find maximum sum of k consecutive elements",
        "file": "sliding_window_operations.py",
        "method": "max_sum_subarray_of_size_k"
      },
      {
        "name": "Minimum Subarray Sum",
        "difficulty": "Easy",
        "description": "Find the minimal length of a contiguous subarray whose sum is greater than or equal to the target.",
        "file": "sliding_window_operations.py",
        "method": "smallest_subarray_with_given_sum"
      },
      {
        "name": "Longest Substring Without Repeating",
        "difficulty": "Medium",
        "description": "Find length of longest substring without repeating characters",
        "file": "sliding_window_operations.py",
        "method": "length_of_longest_substring"
      },
      {
        "name": "Longest Substring with K distincts",
        "difficulty": "Medium",
        "description": "Find the lenght of the longest substring that contains at most k distinct characters",
        "file": "sliding_window_operations.py",
        "method": "longest_substring_with_k_distinct"
      },
      {
        "name": "Fruits into Baskets",
        "difficulty": "Medium",
        "description": "Pick fruits from trees in baskets (one fruit type per basket). Find the maximum number of fruits you can collect with two baskets",
        "file": "sliding_window_operations.py",
        "method": "fruits_into_baskets"
      },
      {
        "name": "Find all anagrams",
        "difficulty": "Medium",
        "description": "Given two strings, return an array of all the start indices of s1's anagrams in s2",
        "file": "sliding_window_operations.py",
        "method": "find_all_anagrams"
      },
      {
        "name": "Longest Repeating Character Replacement",
        "difficulty": "Medium",
        "description": "Find the length of the longest substring with the same characters after replacing at most k characters.",
        "file": "sliding_window_operations.py",
        "method": "longest_repeating_character_replacement"
      },
      {
        "name": "Minimum Window Substring",
        "difficulty": "Hard",
        "description": "Find minimum window containing all characters of pattern",
        "file": "sliding_window_operations.py",
        "method": "min_window_substring"
      },
      {
        "name": "Sliding Window Maximum",
        "difficulty": "Hard",
        "description": "Find maximum in each sliding window of size k",
        "file": "sliding_window_operations.py",
        "method": "sliding_window_maximum"
      },
      {
        "name": "Permutation in String",
        "difficulty": "Medium",
        "description": "Check if string contains permutation of pattern",
        "file": "sliding_window_operations.py",
        "method": "check_inclusion"
      }
    ]
  },
  "hashmaps": {
    "description": "HashMap and HashSet problems",
    "problems": [
      {
        "name": "Valid Anagram",
        "difficulty": "Easy",
        "description": "Check if two strings are anagrams",
        "file": "hashmap_operations.py",
        "method": "is_anagram"
      },
      {
        "name": "Group Anagrams",
        "difficulty": "Medium",
        "description": "Group strings that are anagrams of each other",
        "file": "hashmap_operations.py",
        "method": "group_anagrams"
      },
      {
        "name": "Top K Frequent Elements",
        "difficulty": "Medium",
        "description": "Find k most frequent elements in array",
        "file": "hashmap_operations.py",
        "method": "top_k_frequent"
      },
      {
        "name": "Intersection of Arrays",
        "difficulty": "Easy",
        "description": "Find intersection of two arrays",
        "file": "hashmap_operations.py",
        "method": "intersection"
      },
      {
        "name": "Contains Duplicate",
        "difficulty": "Easy",
        "description": "Check if array contains duplicates",
        "file": "hashmap_operations.py",
        "method": "contains_duplicate"
      },
      {
        "name": "Find all duplicates",
        "difficulty": "Medium",
        "description": "Find all the elements that appear twice in an array",
        "file": "hashmap_operations.py",
        "method": "find_all_duplicates"
      },
      {
        "name": "Union of Arrays",
        "difficulty": "Easy",
        "description": "Find the union of two arrays (all unique elements)",
        "file": "hashmap_operations.py",
        "method": "union_of_arrays"
      },
      {
        "name": "Character Frequency Count",
        "difficulty": "Easy",
        "description": "Count the frequency of each character in a string and return as a hashmap",
        "file": "hashmap_operations.py",
        "method": "character_frequency"
      },
      {
        "name": "First Non-Repeating Character",
        "difficulty": "Easy",
        "description": "Find the first character in a string that doesn't repeat. Return its index or -1",
        "file": "hashmap_operations.py",
        "method": "first_non_repeating_character"
      },
      {
        "name": "Longest Consecutive Sequence",
        "difficulty": "Medium",
        "description": "Find length of longest consecutive sequence",
        "file": "hashmap_operations.py",
        "method": "longest_consecutive"
      },
      {
        "name": "Subarray Sum Equals K",
        "difficulty": "Medium",
        "description": "Find the total number of continuous subarrays whose sum equals k",
        "file": "hashmap_operations.py",
        "method": "subarray_sum_equals_k"
      },
      {
        "name": "4SumII",
        "difficulty": "Medium",
        "description": "Given four arrays, count tuples (i, j, k, l) such that A[i] + B[j] + C[k] + D[l] = 0",
        "file": "hashmap_operations.py",
        "method": "four_sum_count"
      },
      {
        "name": "Valid Sudoku",
        "difficulty": "Medium",
        "description": "Determine if a 9x9 sudoku board is valid (partially filled, checking existing numbers only)",
        "file": "hashmap_operations.py",
        "method": "valid_sudoku"
      }
    ]
  },
  "stacks_queues": {
    "description": "Stack and Queue problems",
    "problems": [
      {
        "name": "Valid Parentheses",
        "difficulty": "Easy",
        "description": "Check if parentheses are properly balanced",
        "file": "stacks_queues_operations.py",
        "method": "valid_parentheses"
      },
      {
        "name": "Daily Temperatures",
        "difficulty": "Medium",
        "description": "Find days until warmer temperature",
        "file": "stacks_queues_operations.py",
        "method": "daily_temperatures"
      },
      {
        "name": "Evaluate Postfix Expression",
        "difficulty": "Medium",
        "description": "Evaluate postfix mathematical expression",
        "file": "stacks_queues_operations.py",
        "method": "evaluate_postfix"
      },
      {
        "name": "Implement Stack with Queues",
        "difficulty": "Easy",
        "description": "Implement stack using only queue operations",
        "file": "stacks_queues_operations.py",
        "method": "implement_stack_using_queues"
      },
      {
        "name": "Implement Queue with Stacks",
        "difficulty": "Easy",
        "description": "Implement queue using only stack operations",
        "file": "stacks_queues_operations.py",
        "method": "implement_queue_using_stacks"
      },
      {
        "name": "Sliding Window Maximum",
        "difficulty": "Hard",
        "description": "Find maximum in sliding window using deque",
        "file": "stacks_queues_operations.py",
        "method": "sliding_window_maximum"
      },
      {
        "name": "First Negative in Window",
        "difficulty": "Easy",
        "description": "Find the first negative number in every window of size k in an array",
        "file": "stacks_queues_operations.py",
        "method": "first_negative_in_window"
      }
    ]
  },
  "linked_lists": {
    "description": "Linked List manipulation problems",
    "problems": [
      {
        "name": "Reverse Linked List",
        "difficulty": "Easy",
        "description": "Reverse a singly linked list",
        "file": "linked_lists_operations.py",
        "method": "reverse_linked_list"
      },
      {
        "name": "Find Middle Node",
        "difficulty": "Easy",
        "description": "Find the middle node of a linked list. If even, return the second middle node",
        "file": "linked_lists_operations.py",
        "method": "find_middle_node"
      },
      {
        "name": "Linked List Cycle Detection",
        "difficulty": "Easy",
        "description": "Detect if linked list has a cycle",
        "file": "linked_lists_operations.py",
        "method": "has_cycle"
      },
      {
        "name": "Find Cycle Start",
        "difficulty": "Medium",
        "description": "Find where cycle begins in linked list",
        "file": "linked_lists_operations.py",
        "method": "find_cycle_start"
      },
      {
        "name": "Merge Two Sorted Lists",
        "difficulty": "Easy",
        "description": "Merge two sorted linked lists",
        "file": "linked_lists_operations.py",
        "method": "merge_two_sorted_lists"
      },
      {
        "name": "Remove Duplicates from Sorted List",
        "difficulty": "Easy",
        "description": "Remove duplicate nodes from a sorted list, keeping only unique values",
        "file": "linked_lists_operations.py",
        "method": "remove_duplicates_sorted"
      },
      {
        "name": "Remove Nth From End",
        "difficulty": "Medium",
        "description": "Remove nth node from end of list",
        "file": "linked_lists_operations.py",
        "method": "remove_nth_from_end"
      },
      {
        "name": "Palindrome Linked List",
        "difficulty": "Easy",
        "description": "Check if linked list is palindrome",
        "file": "linked_lists_operations.py",
        "method": "is_palindrome"
      },
      {
        "name": "Add Two Numbers",
        "difficulty": "Medium",
        "description": "Add numbers represented as linked lists",
        "file": "linked_lists_operations.py",
        "method": "add_two_numbers"
      },
      {
        "name": "Intersection of Two Lists",
        "difficulty": "Easy",
        "description": "Find intersection point of two linked lists",
        "file": "linked_lists_operations.py",
        "method": "intersection_of_two_lists"
      },
      {
        "name": "Partition List",
        "difficulty": "Medium",
        "description": "Partition a linked list around value x, with all nodes < x before nodes >= x",
        "file": "linked_lists_operations.py",
        "method": "partition_list"
      }
    ]
  },
  "binary_trees": {
    "description": "Binary tree operations and traversals",
    "problems": [
      {
        "name": "Inorder Traversal",
        "difficulty": "Easy",
        "description": "Traverse tree in inorder (Left, Root, Right) - both recursive and iterative",
        "file": "binary_trees_operations.py",
        "method": "inorder_traversal_recursive"
      },
      {
        "name": "Preorder Traversal",
        "difficulty": "Easy",
        "description": "Traverse tree in preorder (Root, Left, Right) - both recursive and iterative",
        "file": "binary_trees_operations.py",
        "method": "preorder_traversal_recursive"
      },
      {
        "name": "Postorder Traversal",
        "difficulty": "Easy",
        "description": "Traverse tree in postorder (Left, Right, Root) - both recursive and iterative",
        "file": "binary_trees_operations.py",
        "method": "postorder_traversal_recursive"
      },
      {
        "name": "Level Order Traversal",
        "difficulty": "Medium",
        "description": "Traverse tree level by level using BFS",
        "file": "binary_trees_operations.py",
        "method": "level_order_traversal"
      },
      {
        "name": "Maximum Depth",
        "difficulty": "Easy",
        "description": "Find the maximum depth/height of a binary tree",
        "file": "binary_trees_operations.py",
        "method": "max_depth"
      },
      {
        "name": "Minimum Depth",
        "difficulty": "Easy",
        "description": "Find the minimum depth to any leaf node",
        "file": "binary_trees_operations.py",
        "method": "min_depth"
      },
      {
        "name": "Balanced Binary Tree",
        "difficulty": "Easy",
        "description": "Check if a binary tree is height-balanced",
        "file": "binary_trees_operations.py",
        "method": "is_balanced"
      },
      {
        "name": "Invert Binary Tree",
        "difficulty": "Easy",
        "description": "Invert/flip a binary tree (swap all left and right children)",
        "file": "binary_trees_operations.py",
        "method": "invert_binary_tree"
      },
      {
        "name": "Lowest Common Ancestor",
        "difficulty": "Medium",
        "description": "Find the lowest common ancestor of two nodes in a binary tree",
        "file": "binary_trees_operations.py",
        "method": "lowest_common_ancestor"
      },
      {
        "name": "Path Sum",
        "difficulty": "Easy",
        "description": "Check if tree has a root-to-leaf path with given sum",
        "file": "binary_trees_operations.py",
        "method": "has_path_sum"
      },
      {
        "name": "Path Sum II",
        "difficulty": "Medium",
        "description": "Find all root-to-leaf paths with given sum",
        "file": "binary_trees_operations.py",
        "method": "path_sum_all_paths"
      },
      {
        "name": "Construct Tree from Preorder and Inorder",
        "difficulty": "Medium",
        "description": "Build binary tree from preorder and inorder traversal arrays",
        "file": "binary_trees_operations.py",
        "method": "build_tree_from_preorder_inorder"
      },
      {
        "name": "Serialize and Deserialize Binary Tree",
        "difficulty": "Hard",
        "description": "Convert binary tree to string and back",
        "file": "binary_trees_operations.py",
        "method": "serialize_tree"
      },
      {
        "name": "Validate Binary Search Tree",
        "difficulty": "Medium",
        "description": "Check if a binary tree is a valid binary search tree",
        "file": "binary_trees_operations.py",
        "method": "is_valid_bst"
      },
      {
        "name": "Insert into BST",
        "difficulty": "Medium",
        "description": "Insert a value into a binary search tree",
        "file": "binary_trees_operations.py",
        "method": "bst_insert"
      },
      {
        "name": "Search in BST",
        "difficulty": "Easy",
        "description": "Search for a value in a binary search tree",
        "file": "binary_trees_operations.py",
        "method": "bst_search"
      },
      {
        "name": "Delete Node in BST",
        "difficulty": "Medium",
        "description": "Delete a node from a binary search tree",
        "file": "binary_trees_operations.py",
        "method": "bst_delete"
      },
      {
        "name": "Binary Tree Paths",
        "difficulty": "Easy",
        "description": "Find all root-to-leaf paths in a binary tree",
        "file": "binary_trees_operations.py",
        "method": "binary_tree_paths"
      },
      {
        "name": "Diameter of Binary Tree",
        "difficulty": "Easy",
        "description": "Find the diameter (longest path between any two nodes)",
        "file": "binary_trees_operations.py",
        "method": "diameter_of_binary_tree"
      },
      {
        "name": "Count Complete Tree Nodes",
        "difficulty": "Medium",
        "description": "Count the total number of nodes in a binary tree",
        "file": "binary_trees_operations.py",
        "method": "count_nodes"
      },
      {
        "name": "Symmetric Tree",
        "difficulty": "Easy",
        "description": "Check if a binary tree is symmetric (mirror of itself)",
        "file": "binary_trees_operations.py",
        "method": "is_symmetric"
      },
      {
        "name": "Construct Tree from Array",
        "difficulty": "Medium",
        "description": "Build binary tree from level-order array representation",
        "file": "binary_trees_operations.py",
        "method": "build_tree_from_array"
      }
    ]
  },
  "backtracking": {
    "description": "Backtracking algorithms for constraint satisfaction and exhaustive search",
    "problems": [
      {
        "name": "Generate Permutations",
        "difficulty": "Medium",
        "description": "Generate all permutations of given numbers",
        "file": "backtracking_operations.py",
        "method": "generate_permutations"
      },
      {
        "name": "Generate Combinations",
        "difficulty": "Medium",
        "description": "Generate all combinations of k numbers from 1 to n",
        "file": "backtracking_operations.py",
        "method": "generate_combinations"
      },
      {
        "name": "Generate Subsets",
        "difficulty": "Medium",
        "description": "Generate all possible subsets (power set)",
        "file": "backtracking_operations.py",
        "method": "generate_subsets"
      },
      {
        "name": "N-Queens Problem",
        "difficulty": "Hard",
        "description": "Place N queens on NxN board without attacks",
        "file": "backtracking_operations.py",
        "method": "solve_n_queens"
      },
      {
        "name": "Sudoku Solver",
        "difficulty": "Hard",
        "description": "Solve 9x9 Sudoku puzzle using backtracking",
        "file": "backtracking_operations.py",
        "method": "solve_sudoku"
      },
      {
        "name": "Generate Parentheses",
        "difficulty": "Medium",
        "description": "Generate all valid combinations of n pairs of parentheses",
        "file": "backtracking_operations.py",
        "method": "generate_parentheses"
      },
      {
        "name": "Letter Combinations of Phone Number",
        "difficulty": "Medium",
        "description": "Generate all letter combinations for phone digits",
        "file": "backtracking_operations.py",
        "method": "letter_combinations"
      },
      {
        "name": "Word Search",
        "difficulty": "Medium",
        "description": "Find if word exists in 2D grid using DFS",
        "file": "backtracking_operations.py",
        "method": "word_search"
      },
      {
        "name": "Palindrome Partitioning",
        "difficulty": "Medium",
        "description": "Partition string into palindrome substrings",
        "file": "backtracking_operations.py",
        "method": "palindrome_partitioning"
      },
      {
        "name": "Combination Sum",
        "difficulty": "Medium",
        "description": "Find combinations that sum to target (reuse allowed)",
        "file": "backtracking_operations.py",
        "method": "combination_sum"
      },
      {
        "name": "Subset Sum",
        "difficulty": "Medium",
        "description": "Check if any subset sums to target value",
        "file": "backtracking_operations.py",
        "method": "subset_sum_exists"
      },
      {
        "name": "Restore IP Addresses",
        "difficulty": "Medium",
        "description": "Restore all valid IP addresses from digit string",
        "file": "backtracking_operations.py",
        "method": "restore_ip_addresses"
      },
      {
        "name": "Find All Paths in Maze",
        "difficulty": "Medium",
        "description": "Find all paths from start to end in maze",
        "file": "backtracking_operations.py",
        "method": "find_all_paths"
      },
      {
        "name": "Partition Equal Subset Sum",
        "difficulty": "Medium",
        "description": "Check if array can be partitioned into two equal subsets",
        "file": "backtracking_operations.py",
        "method": "partition_equal_subset_sum"
      },
      {
        "name": "Generate Unique Permutations",
        "difficulty": "Medium",
        "description": "Generate unique permutations with duplicate elements",
        "file": "backtracking_operations.py",
        "method": "generate_unique_permutations"
      }
    ]
  },
  "dynamic_programming": {
    "description": "Dynamic Programming algorithms for optimization and counting problems",
    "problems": [
      {
        "name": "Fibonacci",
        "difficulty": "Easy",
        "description": "Calculate the nth fibonacci number using dynamic programming",
        "file": "dp1_operations.py",
        "method": "fibonacci"
      },
      {
        "name": "Climbing Stairs",
        "difficulty": "Easy",
        "description": "Calculate the number of distinct ways to climb n stairs (can step 1 or 2 steps at a time)",
        "file": "dp1_operations.py",
        "method": "climbing_stairs"
      },
      {
        "name": "House Robber",
        "difficulty": "Medium",
        "description": "Find the maximum money that can be robbed without robbing adjacent houses",
        "file": "dp1_operations.py",
        "method": "house_robber"
      },
      {
        "name": "Coin Change",
        "difficulty": "Medium",
        "description": "Find the minimum number of coins needed to make the given amount",
        "file": "dp1_operations.py",
        "method": "coin_change"
      },
      {
        "name": "Longest Increasing Subsequence",
        "difficulty": "Medium",
        "description": "Find the length of the longest strictly increasing subsequence",
        "file": "dp1_operations.py",
        "method": "longest_increasing_subsequence"
      },
      {
        "name": "Word Break",
        "difficulty": "Medium",
        "description": "Check if string can be segmented into dictionary words",
        "file": "dp1_operations.py",
        "method": "word_break"
      },
      {
        "name": "Best Time to Buy and Sell Stock",
        "difficulty": "Easy",
        "description": "Find maximum profit from a single buy/sell transaction",
        "file": "dp1_operations.py",
        "method": "buy_sell_stock1"
      },
      {
        "name": "Best Time to Buy and Sell Stock II",
        "difficulty": "Medium",
        "description": "Find maximum profit from multiple buy/sell transactions",
        "file": "dp1_operations.py",
        "method": "buy_sell_stock2"
      },
      {
        "name": "Longest Palindromic Substring",
        "difficulty": "Medium",
        "description": "Find the longest palindromic substring in a string",
        "file": "dp1_operations.py",
        "method": "longest_palindromic_substring"
      }
    ]
  }
}